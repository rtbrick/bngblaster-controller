// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package controller

import (
	"sync"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			AllowUploadFunc: func() bool {
//				panic("mock out the AllowUpload method")
//			},
//			CommandFunc: func(name string, command SocketCommand) ([]byte, error) {
//				panic("mock out the Command method")
//			},
//			ConfigFolderFunc: func() string {
//				panic("mock out the ConfigFolder method")
//			},
//			CreateFunc: func(name string, config []byte) error {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(name string) error {
//				panic("mock out the Delete method")
//			},
//			ExecutableFunc: func() string {
//				panic("mock out the Executable method")
//			},
//			ExistsFunc: func(name string) bool {
//				panic("mock out the Exists method")
//			},
//			InstancesFunc: func() []string {
//				panic("mock out the Instances method")
//			},
//			KillFunc: func(name string)  {
//				panic("mock out the Kill method")
//			},
//			RunningFunc: func(name string) bool {
//				panic("mock out the Running method")
//			},
//			StartFunc: func(name string, runningConfig RunningConfig) error {
//				panic("mock out the Start method")
//			},
//			StopFunc: func(name string)  {
//				panic("mock out the Stop method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// AllowUploadFunc mocks the AllowUpload method.
	AllowUploadFunc func() bool

	// CommandFunc mocks the Command method.
	CommandFunc func(name string, command SocketCommand) ([]byte, error)

	// ConfigFolderFunc mocks the ConfigFolder method.
	ConfigFolderFunc func() string

	// CreateFunc mocks the Create method.
	CreateFunc func(name string, config []byte) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(name string) error

	// ExecutableFunc mocks the Executable method.
	ExecutableFunc func() string

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(name string) bool

	// InstancesFunc mocks the Instances method.
	InstancesFunc func() []string

	// KillFunc mocks the Kill method.
	KillFunc func(name string)

	// RunningFunc mocks the Running method.
	RunningFunc func(name string) bool

	// StartFunc mocks the Start method.
	StartFunc func(name string, runningConfig RunningConfig) error

	// StopFunc mocks the Stop method.
	StopFunc func(name string)

	// calls tracks calls to the methods.
	calls struct {
		// AllowUpload holds details about calls to the AllowUpload method.
		AllowUpload []struct {
		}
		// Command holds details about calls to the Command method.
		Command []struct {
			// Name is the name argument value.
			Name string
			// Command is the command argument value.
			Command SocketCommand
		}
		// ConfigFolder holds details about calls to the ConfigFolder method.
		ConfigFolder []struct {
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Name is the name argument value.
			Name string
			// Config is the config argument value.
			Config []byte
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Name is the name argument value.
			Name string
		}
		// Executable holds details about calls to the Executable method.
		Executable []struct {
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Name is the name argument value.
			Name string
		}
		// Instances holds details about calls to the Instances method.
		Instances []struct {
		}
		// Kill holds details about calls to the Kill method.
		Kill []struct {
			// Name is the name argument value.
			Name string
		}
		// Running holds details about calls to the Running method.
		Running []struct {
			// Name is the name argument value.
			Name string
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Name is the name argument value.
			Name string
			// RunningConfig is the runningConfig argument value.
			RunningConfig RunningConfig
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
			// Name is the name argument value.
			Name string
		}
	}
	lockAllowUpload  sync.RWMutex
	lockCommand      sync.RWMutex
	lockConfigFolder sync.RWMutex
	lockCreate       sync.RWMutex
	lockDelete       sync.RWMutex
	lockExecutable   sync.RWMutex
	lockExists       sync.RWMutex
	lockInstances    sync.RWMutex
	lockKill         sync.RWMutex
	lockRunning      sync.RWMutex
	lockStart        sync.RWMutex
	lockStop         sync.RWMutex
}

// AllowUpload calls AllowUploadFunc.
func (mock *RepositoryMock) AllowUpload() bool {
	if mock.AllowUploadFunc == nil {
		panic("RepositoryMock.AllowUploadFunc: method is nil but Repository.AllowUpload was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAllowUpload.Lock()
	mock.calls.AllowUpload = append(mock.calls.AllowUpload, callInfo)
	mock.lockAllowUpload.Unlock()
	return mock.AllowUploadFunc()
}

// AllowUploadCalls gets all the calls that were made to AllowUpload.
// Check the length with:
//
//	len(mockedRepository.AllowUploadCalls())
func (mock *RepositoryMock) AllowUploadCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAllowUpload.RLock()
	calls = mock.calls.AllowUpload
	mock.lockAllowUpload.RUnlock()
	return calls
}

// Command calls CommandFunc.
func (mock *RepositoryMock) Command(name string, command SocketCommand) ([]byte, error) {
	if mock.CommandFunc == nil {
		panic("RepositoryMock.CommandFunc: method is nil but Repository.Command was just called")
	}
	callInfo := struct {
		Name    string
		Command SocketCommand
	}{
		Name:    name,
		Command: command,
	}
	mock.lockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	mock.lockCommand.Unlock()
	return mock.CommandFunc(name, command)
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//
//	len(mockedRepository.CommandCalls())
func (mock *RepositoryMock) CommandCalls() []struct {
	Name    string
	Command SocketCommand
} {
	var calls []struct {
		Name    string
		Command SocketCommand
	}
	mock.lockCommand.RLock()
	calls = mock.calls.Command
	mock.lockCommand.RUnlock()
	return calls
}

// ConfigFolder calls ConfigFolderFunc.
func (mock *RepositoryMock) ConfigFolder() string {
	if mock.ConfigFolderFunc == nil {
		panic("RepositoryMock.ConfigFolderFunc: method is nil but Repository.ConfigFolder was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConfigFolder.Lock()
	mock.calls.ConfigFolder = append(mock.calls.ConfigFolder, callInfo)
	mock.lockConfigFolder.Unlock()
	return mock.ConfigFolderFunc()
}

// ConfigFolderCalls gets all the calls that were made to ConfigFolder.
// Check the length with:
//
//	len(mockedRepository.ConfigFolderCalls())
func (mock *RepositoryMock) ConfigFolderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConfigFolder.RLock()
	calls = mock.calls.ConfigFolder
	mock.lockConfigFolder.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *RepositoryMock) Create(name string, config []byte) error {
	if mock.CreateFunc == nil {
		panic("RepositoryMock.CreateFunc: method is nil but Repository.Create was just called")
	}
	callInfo := struct {
		Name   string
		Config []byte
	}{
		Name:   name,
		Config: config,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(name, config)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedRepository.CreateCalls())
func (mock *RepositoryMock) CreateCalls() []struct {
	Name   string
	Config []byte
} {
	var calls []struct {
		Name   string
		Config []byte
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *RepositoryMock) Delete(name string) error {
	if mock.DeleteFunc == nil {
		panic("RepositoryMock.DeleteFunc: method is nil but Repository.Delete was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(name)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRepository.DeleteCalls())
func (mock *RepositoryMock) DeleteCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Executable calls ExecutableFunc.
func (mock *RepositoryMock) Executable() string {
	if mock.ExecutableFunc == nil {
		panic("RepositoryMock.ExecutableFunc: method is nil but Repository.Executable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExecutable.Lock()
	mock.calls.Executable = append(mock.calls.Executable, callInfo)
	mock.lockExecutable.Unlock()
	return mock.ExecutableFunc()
}

// ExecutableCalls gets all the calls that were made to Executable.
// Check the length with:
//
//	len(mockedRepository.ExecutableCalls())
func (mock *RepositoryMock) ExecutableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExecutable.RLock()
	calls = mock.calls.Executable
	mock.lockExecutable.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *RepositoryMock) Exists(name string) bool {
	if mock.ExistsFunc == nil {
		panic("RepositoryMock.ExistsFunc: method is nil but Repository.Exists was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(name)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedRepository.ExistsCalls())
func (mock *RepositoryMock) ExistsCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Instances calls InstancesFunc.
func (mock *RepositoryMock) Instances() []string {
	if mock.InstancesFunc == nil {
		panic("RepositoryMock.InstancesFunc: method is nil but Repository.Instances was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInstances.Lock()
	mock.calls.Instances = append(mock.calls.Instances, callInfo)
	mock.lockInstances.Unlock()
	return mock.InstancesFunc()
}

// InstancesCalls gets all the calls that were made to Instances.
// Check the length with:
//
//	len(mockedRepository.InstancesCalls())
func (mock *RepositoryMock) InstancesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInstances.RLock()
	calls = mock.calls.Instances
	mock.lockInstances.RUnlock()
	return calls
}

// Kill calls KillFunc.
func (mock *RepositoryMock) Kill(name string) {
	if mock.KillFunc == nil {
		panic("RepositoryMock.KillFunc: method is nil but Repository.Kill was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockKill.Lock()
	mock.calls.Kill = append(mock.calls.Kill, callInfo)
	mock.lockKill.Unlock()
	mock.KillFunc(name)
}

// KillCalls gets all the calls that were made to Kill.
// Check the length with:
//
//	len(mockedRepository.KillCalls())
func (mock *RepositoryMock) KillCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockKill.RLock()
	calls = mock.calls.Kill
	mock.lockKill.RUnlock()
	return calls
}

// Running calls RunningFunc.
func (mock *RepositoryMock) Running(name string) bool {
	if mock.RunningFunc == nil {
		panic("RepositoryMock.RunningFunc: method is nil but Repository.Running was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockRunning.Lock()
	mock.calls.Running = append(mock.calls.Running, callInfo)
	mock.lockRunning.Unlock()
	return mock.RunningFunc(name)
}

// RunningCalls gets all the calls that were made to Running.
// Check the length with:
//
//	len(mockedRepository.RunningCalls())
func (mock *RepositoryMock) RunningCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockRunning.RLock()
	calls = mock.calls.Running
	mock.lockRunning.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *RepositoryMock) Start(name string, runningConfig RunningConfig) error {
	if mock.StartFunc == nil {
		panic("RepositoryMock.StartFunc: method is nil but Repository.Start was just called")
	}
	callInfo := struct {
		Name          string
		RunningConfig RunningConfig
	}{
		Name:          name,
		RunningConfig: runningConfig,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(name, runningConfig)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedRepository.StartCalls())
func (mock *RepositoryMock) StartCalls() []struct {
	Name          string
	RunningConfig RunningConfig
} {
	var calls []struct {
		Name          string
		RunningConfig RunningConfig
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *RepositoryMock) Stop(name string) {
	if mock.StopFunc == nil {
		panic("RepositoryMock.StopFunc: method is nil but Repository.Stop was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	mock.StopFunc(name)
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//
//	len(mockedRepository.StopCalls())
func (mock *RepositoryMock) StopCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}
